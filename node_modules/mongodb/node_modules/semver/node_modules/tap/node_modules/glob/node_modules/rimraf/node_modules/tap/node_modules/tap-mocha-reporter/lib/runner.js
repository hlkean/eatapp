// A facade from the tap-parser to the Mocha "Runner" object.
// Note that pass/fail/suite events need to also mock the "Runnable"
// objects (either "Suite" or "Test") since these have functions
// which are called by the formatters.

module.exports = Runner

// relevant events:
//
// start()
//   Start of the top-level test set
//
// end()
//   End of the top-level test set.
//
// fail(test, err)
//   any "not ok" test that is not the trailing test for a suite
//   of >0 test points.
//
// pass(test)
//   any "ok" test point that is not the trailing test for a suite
//   of >0 tests
//
// pending(test)
//   Any "todo" test
//
// suite(suite)
//   A suite is a child test with >0 test points.  This is a little bit
//   tricky, because TAP will provide a "child" event before we know
//   that it's a "suite".  We see the "# Subtest: name" comment as the
//   first thing in the subtest.  Then, when we get our first test point,
//   we know that it's a suite, and can emit the event with the mock suite.
//
// suite end(suite)
//   Emitted when we end the subtest
//
// test(test)
//   Any test point which is not the trailing test for a suite.
//
// test end(test)
//   Emitted immediately after the "test" event because test points are
//   not async in TAP.

var util = require('util')
var Test = require('./test.js')
var Suite = require('./suite.js')
var Writable = require('stream').Writable
if (!Writable) {
  try {
    Writable = require('readable-stream').Writable
  } catch (er) {
    throw new Error('Please install "readable-stream" to use this module ' +
                    'with Node.js v0.8 and before')
  }
}

var Parser = require('tap-parser')

// $1 = number, $2 = units
var timere = /^#\s*time=((?:0|[1-9][0-9]*?)(?:\.[0-9]+)?)(ms|s)?$/

util.inherits(Runner, Writable)

function Runner (options) {
  if (!(this instanceof Runner))
    return new Runner(options)

  var parser = this.parser = new Parser(options)
  this.startTime = new Date()

  attachEvents(this, parser, 0)
  Writable.call(this, options)
}

Runner.pr