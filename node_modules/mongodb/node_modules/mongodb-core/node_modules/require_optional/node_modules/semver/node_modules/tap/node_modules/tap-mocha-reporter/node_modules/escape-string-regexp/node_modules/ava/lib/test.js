'use strict';
var isGeneratorFn = require('is-generator-fn');
var maxTimeout = require('max-timeout');
var Promise = require('bluebird');
var fnName = require('fn-name');
var co = require('co-with-promise');
var observableToPromise = require('observable-to-promise');
var isPromise = require('is-promise');
var isObservable = require('is-observable');
var inspect = require('util').inspect;
var assert = require('./assert');
var enhanceAssert = require('./enhance-assert');
var globals = require('./globals');

function Test(title, fn, contextRef, report) {
	if (!(this instanceof Test)) {
		throw new TypeError('Class constructor Test cannot be invoked without \'new\'');
	}

	if (typeof title === 'function') {
		contextRef = fn;
		fn = title;
		title = null;
	}

	assert.is(typeof fn, 'function', 'you must provide a callback');

	this.title = title || fnName(fn) || '[anonymous]';
	this.fn = isGeneratorFn(fn) ? co.wrap(fn) : fn;
	this.assertions = [];
	this.planCount = null;
	this.duration = null;
	this.assertError = undefined;
	this.sync = true;
	this.contextRef = contextRef;
	this.report = report;

	// TODO(jamestalmage): make this an optional constructor arg instead of having Runner set it after the fact.
	// metadata should just always exist, otherwise it requires a bunch of ugly checks all over the place.
	this.metadata = {};

	// store the time point before test execution
	// to calculate the total time spent in test
	this._timeStart = null;

	// workaround for Babel giving anonymous functions a name
	if (this.title === 'callee$0$0') {
		this.title = '[anonymous]';
	}
}

module.exports = Test;

Object.defineProperty(Test.prototype, 'assertCount', {
	enumerable: true,
	get: function () {
		return this.assertions.length;
	}
});

Test.prototype._assert = function (promise) {
	if (isPromise(promise)) {
		this.sync = false;
	}

	this.assertions.push(promise);
};

Test.prototype._setAssertError = function (err) {
	if (this.assertError !== undefined) {
		return;
	}

	this.assertError = err;
};

Test.prototype.plan = function (count, planStack) {
	if (typeof count !== 'number') {
		throw new TypeError('Expected a number');
	}

	this.planCount = count;

	// in case the `planCount` doesn't match `assertCount,
	// we need the stack of this function to throw with a useful stack
	this.planStack = planStack;
};

Test.prototype._run = function () {
	var ret;

	try {
		ret = this.fn(this._publicApi());
	} catch (err) {
		if (err instanceof Error) {
			this._setAssertError(err);
		} else {
			this._setAssertError(new assert.AssertionError({
				actual: err,
				message: 'Non-error thrown with value: ' + inspect(err, {depth: null}),
				operator: 'catch'
			}));
		}
	}

	return ret;
};

Test.prototype.promise = function () {
	var self = this;

	if (!this._promise) {
		this._promise = {};

		this._promise.promise = new Promise(function (resolve, reject) { // eslint-disable-line
			self._promise.resolve = resolve;
			self._promise.reject = reject;
		}).tap(function (result) {
			if (self.report) {
				self.report(result);
			}
		});
	}

	r