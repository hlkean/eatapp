# tape

tap-producing test harness for node and browsers

[![browser support](https://ci.testling.com/substack/tape.png)](http://ci.testling.com/substack/tape)

[![build status](https://secure.travis-ci.org/substack/tape.png)](http://travis-ci.org/substack/tape)

![tape](http://substack.net/images/tape_drive.png)

# example

``` js
var test = require('tape');

test('timing test', function (t) {
    t.plan(2);
    
    t.equal(typeof Date.now, 'function');
    var start = Date.now();
    
    setTimeout(function () {
        t.equal(Date.now() - start, 100);
    }, 100);
});
```

```
$ node example/timing.js
TAP version 13
# timing test
ok 1 should be equal
not ok 2 should be equal
  ---
    operator: equal
    expected: 100
    actual:   107
  ...

1..2
# tests 2
# pass  1
# fail  1
```

# usage

You always need to `require('tape')` in test files. You can run the tests by
usual node means (`require('test-file.js')` or `node test-file.js`). You can
also run tests using the `tape` binary to utilize globbing, on Windows for
example:

```sh
$ tape tests/**/*.js
```

`tape`'s arguments are passed to the
[`glob`](https://www.npmjs.com/package/glob) module. If you want `glob` to
perform the expansion on a system where the shell performs such expansion, quote
the arguments as necessary:

```sh
$ tape 'tests/**/*.js'
$ tape "tests/**/*.js"
```

## Preloading modules

Additionally, it is possible to make `tape` load one or more modules before running any tests, by using the `-r` or `--require` flag. Here's an example that loads [babel-register](http://babeljs.io/docs/usage/require/) before running any tests, to allow for JIT compilation:

```sh
$ tape -r babel-register tests/**/*.js
```

Depending on the module you're loading, you may be able to paramaterize it using environment variables or auxiliary files. Babel, for instance, will load options from [`.babelrc`](http://babeljs.io/docs/usage/babelrc/) at runtime.

The `-r` flag behaves exactly like node's `require`, and uses the same module resolution algorithm. This means that if you need to load local modules, you have to prepend their path with `./` or `../` accordingly.

For example:

```sh
$ tape -r ./my/local/module tests/**/*.js
```

Please note that modules that all modules loaded using the `-r` flag will run *before* any tests, regardless of when they are specified. For example, `tape -r a b -r c` will actually load `a` and `c` *before` loading `b`, since they are flagged as required modules.

# things that go well with tape

tape maintains a fairly minimal core. Additional features are usually added by using another module alongside tape.

## pretty reporters

The default TAP output is good for machines and humans that are robots.

If you want a more colorful / pretty output there are lots of modules on npm
that will output something pretty if you pipe TAP into them:

 - https://github.com/scottcorgan/tap-spec
 - https://github.com/scottcorgan/tap-dot
 - https://github.com/substack/faucet
 - https://github.com/juliangruber/tap-bail
 - https://github.com/kirbysayshi/tap-browser-color
 - https://github.com/gummesson/tap-json
 - https://github.com/gummesson/tap-min
 - https://github.com/calvinmetcalf/tap-nyan
 - https://www.npmjs.org/package/tap-pessimist
 - https://github.com/toolness/tap-prettify
 - https://github.com/shuhei/colortape
 - https://github.com/aghassemi/tap-xunit
 - https://github.com/namuol/tap-difflet
 - https://github.com/gritzko/tape-dom
 - https://github.com/axross/tap-diff
 - https://github.com/axross/tap-notify

To use them, try `node test/index.js | tap-spec` or pipe it into one
of the modules of your choice!

## uncaught exceptions

By default, uncaught exceptions in your tests will not be intercepted, and will cause tape to crash. If you find this behavior undesirable, use [tape-catch](https://github.com/michaelrhodes/tape-catch) to report any exceptions as TAP errors.

## other

- CoffeeScript support with https://www.npmjs.com/package/coffeetape
- Promise support with https://www.npmjs.com/package/blue-tape
- ES6 support with https://www.npmjs.com/package/babel-tape-runner

# methods

The assertion methods in tape are heavily influenced or copied from the methods
in [node-tap](https://github.com/isaacs/node-tap).

```
var test = require('tape')
```

## test([name], [opts], cb)

Create a new test with an optional `name` string and optional `opts` object. 
`cb(t)` fires with the new test object `t` once all preceeding tests have
finished. Tests execute serially.

Available `opts` options are:
- opts.skip = true/false. See test.skip.
- opts.timeout = 500. Set a timeout for the test, after which it will fail. 
  See test.timeoutAfter.

If you forget to `t.plan()` out how many assertions you are going to run and you
don't call `t.end()` explicitly, your test will hang.

## test.skip(name, cb)

Generate a new test that will be skipped over.

## test.onFinish(fn)

The onFinish hook will get invoked when ALL tape tests have finished
right before tape is about to print the test summary.

## t.plan(n)

Declare that `n` assertions should be run. `t.end()` will be called
automatically after the `n`th assertion. If there are any more assertions after
the `n`th, or after `t.end()` is called, they will generate errors.

## t.end(err)

Declare the end of a test explicitly. If `err` is passed in `t.end` will assert
that it is falsey.

## t.fail(msg)

Generate a failing assertion with a message `msg`.

## t.pass(msg)

Generate a passing assertion with a message `msg`.

## t.timeoutAfter(ms)

Automatically timeout the test after X ms.

## t.skip(msg)
 
Generate an assertion that will be skipped over.

## t.ok(value, msg)

Assert that `value` is truthy with an optional description message `msg`.

Aliases: `t.true()`, `t.assert()`

## t.notOk(value, msg)

Assert that `value` is falsy with an optional description message `msg`.

Aliases: `t.false()`, `t.notok()`

## t.error(err, msg)

Assert that `err` is falsy. If `err` is non-falsy, use its `err.message` as the
description message.

Aliases: `t.ifError()`, `t.ifErr()`, `t.iferror()`

## t.equal(actual, expected, msg)

Assert that `actual === expected` with an optional description `msg`.

Aliases: `t.equals()`, `t.isEqual()`, `t.is()`, `t.strictEqual()`,
`t.strictEquals()`

## t.notEqual(actual, expected, msg)

Assert that `actual !== expected` with an optional description `msg`.

Aliases: `t.notEquals()`, `t.notStrictEqual()`, `t.notStrictEquals()`,
`t.isNotEqual()`, `t.isNot()`, `t.not()`, `t.doesNotEqual()`, `t.isInequal()`

## t.deepEqual(actual, expected, msg)

Assert that `actual` and `expected` have the same structure and nested values using
[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)
with strict comparisons (`===`) on leaf nodes and an optional description
`msg`.

Aliases: `t.deepEquals()`, `t.isEquivalent()`, `t.same()`

## t.notDeepEqual(actual, expected, msg)

Assert that `actual` and `expected` do not have the same structure and nested values using
[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)
with strict comparisons (`===`) on leaf nodes and an optional description
`msg`.

Aliases: `t.notEquivalent()`, `t.notDeeply()`, `t.notSame()`,
`t.isNotDeepEqual()`, `t.isNotDeeply()`, `t.isNotEquivalent()`,
`t.isInequivalent()`

## t.deepLooseEqual(actual, expected, msg)

Assert that `actual` and `expected` have the same structure and nested values using
[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)
with loose comparisons (`==`) on leaf nodes and an optional description `msg`.

Aliases: `t.looseEqual()`, `t.looseEquals()`

## t.notDeepLoo