# micromatch [![NPM version](https://badge.fury.io/js/micromatch.svg)](http://badge.fury.io/js/micromatch)  [![Build Status](https://travis-ci.org/jonschlinkert/micromatch.svg)](https://travis-ci.org/jonschlinkert/micromatch)

> Glob matching for javascript/node.js. A drop-in replacement and faster alternative to minimatch and multimatch. Just use `micromatch.isMatch()` instead of `minimatch()`, or use `micromatch()` instead of `multimatch()`.

## Install

Install with [npm](https://www.npmjs.com/)

```sh
$ npm i micromatch --save
```

## Table of contents

<!-- toc -->

* [Features](#features)
* [Usage](#usage)
* [Switch from minimatch](#switch-from-minimatch)
* [Methods](#methods)
  - [.isMatch](#ismatch)
  - [.contains](#contains)
  - [.matcher](#matcher)
  - [.filter](#filter)
  - [.any](#any)
  - [.expand](#expand)
  - [.makeRe](#makere)
* [Options](#options)
  - [options.unixify](#optionsunixify)
  - [options.dot](#optionsdot)
  - [options.unescape](#optionsunescape)
  - [options.nodupes](#optionsnodupes)
  - [options.matchBase](#optionsmatchbase)
  - [options.nobraces](#optionsnobraces)
  - [options.nobrackets](#optionsnobrackets)
  - [options.noextglob](#optionsnoextglob)
  - [options.nocase](#optionsnocase)
  - [options.nonull](#optionsnonull)
  - [options.cache](#optionscache)
* [Other features](#other-features)
  - [Extended globbing](#extended-globbing)
    + [extglobs](#extglobs)
    + [brace expansion](#brace-expansion)
    + [regex character classes](#regex-character-classes)
    + [regex groups](#regex-groups)
    + [POSIX bracket expressions](#posix-bracket-expressions)
* [Notes](#notes)
* [Benchmarks](#benchmarks)
* [Run tests](#run-tests)
* [Contributing](#contributing)
* [Related](#related)
* [Author](#author)
* [License](#license)

_(Table of contents generated by [verb](https://github.com/verbose/verb))_

<!-- tocstop -->

## Features

Micromatch is [10-55x faster](#benchmarks) than [minimatch](https://github.com/isaacs/minimatch), resulting from a combination of caching, tokenization, parsing, runtime compilation and regex optimization strategies.

* [Drop-in replacement](#switch-from-minimatch) for [minimatch](https://github.com/isaacs/minimatch) and [multimatch](https://github.com/sindresorhus/multimatch)
* Built-in support for multiple glob patterns, like `['foo/*.js', '!bar.js']`
* Better support for the Bash 4.3 specification, and less buggy
* Extensive [unit tests](./test) (approx. 1,300 tests). Minimatch fails many of the tests.

**Mainstream glob features:**

* [Brace Expansion](https://github.com/jonschlinkert/braces) (`foo/bar-{1..5}.md`, `one/{two,three}/four.md`)
* Typical glob patterns, like `**/*`, `a/b/*.js`, or `['foo/*.js', '!bar.js']`

**Extended globbing features:**

* Logical `OR` (`foo/bar/(abc|xyz).js`)
* Regex character classes (`foo/bar/baz-[1-5].js`)
* POSIX [bracket expressions](https://github.com/jonschlinkert/expand-brackets) (`**/[[:alpha:][:digit:]]/`)
* [extglobs](https://github.com/jonschlinkert/extglob) (`**/+(x|y)`, `!(a|b)`, etc)

You can combine these to create whatever matching patterns you need.

## Usage

```js
var mm = require('micromatch');
mm(array, patterns);
```

**Examples**

```js
mm(['a.js', 'b.md', 'c.txt'], '*.{js,txt}');
//=> ['a.js', 'c.txt']
```

**Multiple patterns**

Multiple patterns can also be passed:

```js
mm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.md', '*.txt']);
//=> ['a.md', 'c.txt']
```

**Negation patterns:**

Behavior;

* when the pattern is a string, [minimatch](https://github.com/isaacs/minimatch) behavior is used, so patterns are **inclusive by default**.
* when an array of patterns is passed, [multimatch](https://github.com/sindresorhus/multimatch) behavior is used, so patterns are **exclusive by default**

```js
mm(['a.js', 'b.md', 'c.txt'], '!*.{js,txt}');
//=> ['b.md']

mm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.*', '!*.{js,txt}']);
//=> ['a.md', 'd.json']
```

## Switch from minimatch

> Use `micromatch.isMatch()` instead of `minimatch()`

**Minimatch**

The main `minimatch()` function returns true/false for a single file path and pattern:

```js
var minimatch = require('minimatch');
minimatch('foo.js', '*.js');
//=> 'true'
```

**Micromatch**

With micromatch, `.isMatch()` to get the same result:

```js
var mm = require('micromatch');
mm.isMatch('foo.js', '*.js');
//=> 'true'
```

This implementation difference is necessary since the main `micromatch()` method supports matching on multiple globs, with behavior similar to [multimatch](https://github.com/sindresorhus/multimatch).

## Methods

```js
var mm = require('micromatch');
```

### .isMatch

```js
mm.isMatch(filepath, globPattern);
```

Returns true if a file path matches the given glob pattern.

**Example**

```js
mm.isMatch('.verb.md', '*.md');
//=> false

mm.isMatch('.verb.md', '*.md', {dot: true});
//=> true
```

### .contains

Returns true if any part of a file path matches the given glob pattern. Think of this is "has path" versus "is path".

**Example**

`.isMatch()` would return false for both of the following:

```js
mm.contains('a/b/c', 'a/b');
//=> true

mm.contains('a/b/c', 'a/*');
//=> true
```

### .matcher

Returns a function for matching using the supplied pattern. e.g. create your own "matcher". The advantage of this method is that the pattern can be compiled outside of a loop.

**Pattern**

Can be any of the following:

* `glob/string`
* `regex`
* `function`

**Example**

```js
var isMatch = mm.matcher('*.md');
var files = [];

['a.md', 'b.txt', 'c.md'].forEach(function(fp) {
  if (isMatch(fp)) {
    files.push(fp);
  }
});
```

### .filter

Returns a function that can be passed to `Array#filter()`.

**Params**

* `patterns` **{String|Array}**:

**Examples**

Single glob:

```js
var fn = mm.filter('*.md');
['a.js', 'b.txt', 'c.md'].filter(fn);
//=> ['c.md']

var fn = mm.filter('[a-c]');
['a', 'b', 'c', 'd', 'e'].filter(fn);
//=> ['a', 'b', 'c']
```

Array of glob patterns:

```js
var arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];

var fn = mm.filter(['{1..10}', '![7-9]', '!{3..4}']);
arr.filter(fn);
//=> [1, 2, 5, 6, 10]
```

_(Internally this function generates the matching function by using the [matcher](#matcher) method. You can use the [matcher](#matcher) method directly to create your own filter function)_

### .any

Returns true if a file path matches any of the given patterns.

```js
mm.any(filepath, patterns, options);
```

**Params**

* filepath `{String}`: The file path to test.
* patterns `{String|Array}`: One or more glob patterns
* options: `{Object}`: options to pass to the `.matcher()` method.

**Example**

```js
mm.any('abc', ['!*z']);
//=> true
m