module.exports = Test

var Readable = require('stream').Readable
if (!Readable || process.version.match(/^v0\.10/)) {
  Readable = require('readable-stream').Readable
}

var util = require('util')
util.inherits(Test, Readable)

var yaml = require('js-yaml')
var stack = require('./stack.js')
var tapAsserts = require('./assert.js')
var assert = require('assert')
var spawn = require('child_process').spawn
var Parser = require('tap-parser')
var path = require('path')
var Module = require('module').Module
var fs = require('fs')
var binpath = path.resolve(__dirname, '../bin')


function hasOwn (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function Test (options) {
  options = options || {}

  if (!(this instanceof Test))
    return new Test(options)

  this._autoend = !!options.autoend
  this._name = ''
  this._ok = true
  this._pass = 0
  this._fail = 0
  this._skip = 0
  this._todo = 0
  this._count = 0
  this._bailedOut = false
  this._endEmitted = false

  if (Object.prototype.hasOwnProperty.call(options, 'bail'))
    this._bail = !!options.bail
  else
    this._bail = process.env.TAP_BAIL === '1'

  this._passes = []
  this._fails = []
  this._skips = []
  this._todos = []

  this._plan = -1
  this._queue = []
  this._currentChild = null
  this._ending = false
  this._ended = false
  this._planFinished = false

  this._parent = null
  this._printedVersion = false

  this._startTime = process.hrtime()
  this._calledAt = options.at || stack.at(this.test)
  if (!this._calledAt || !this._calledAt.file)
    this._calledAt = stack.at(Test)

  this._timer = null
  this._timeout = 0
  if (options.timeout !== Infinity &&
      !isNaN(options.timeout) &&
      options.timeout > 0) {
    this.setTimeout(options.timeout)
  }

  Readable.apply(this, options)

  // Bind all methods.
  var bound = {}
  for (var m in this) {
    if (typeof this[m] === 'function') {
      this[m] = this[m].bind(this)
      bound[m] = true
    }
  }
  Object.getOwnPropertyNames(Test.prototype).forEach(function (name) {
    if (typeof this[name] === 'function' && !bound[name]) {
      Object.defineProperty(this, name, {
        value: this[name].bind(this),
        enumerable: false,
        configurable: true,
        writable: true
      })
    }
  }, this)

}

Test.prototype.tearDown = Test.prototype.teardown = function (fn) {
  this.on('end', fn)
}

Test.prototype.setTimeout = function (n) {
  if (n === Infinity) {
    if (this._timer)
      clearTimeout(this._timer)
    this._timeout = 0
    return
  }

  if (isNaN(n) || n <= 0)
    throw new TypeError('setTimeout: number > 0 required')

  this._timeout = n
  if (this._timer)
    clearTimeout(this._timer)

  var self = this
  this._timer = setTimeout(function () {
    self._onTimeout()
  }, n)
}

Test.prototype._onTimeout = function () {
  var s = this
  while (s._currentChild && (s._currentChild instanceof Test)) {
    s._queue = []
    s.end()
    s = s._currentChild
  }

  // anything that was pending will have to wait.
  s.fail('timeout!', {
    expired: this._name,
    timeout: this._timeout,
    at: this._calledAt
  })
  s.end()

  this.endAll()
}

// Called when endAll() is fired and there's stuff in the queue
Test.prototype._queueFail = function () {
  var queue = this._queue
  this._queue = []
  var len = queue.length

  queue.forEach(function (q) {
    var what = q[0]
    var msg = what + ' left in queue'
    var extra = { at: this._calledAt }

    switch (what) {
    case 'test':
      extra = q[2]
      msg = 'child test left in queue: ' + (q[1] || '(unnamed)')
      break

    case 'printResult':
      if (q[2] === 'test unfinished: ' + (this._name || '(unnamed)'))
        return
      var msg = (q[1] ? 'ok' : 'not ok') + ' - ' + q[2].trim()
      msg = 'test point left in queue: ' + msg
      extra = q[3]
      extra.at = extra.at || null
      break

    case 'spawn':
      extra = q[5]
      extra.command = q[1]
      extra.args = q[2]
      extra.options = q[3]
      msg = 'spawn left in queue: ' + (q[4] || '(unnamed)')
      break

    case 'end':
      return
    }

    if (this._parent)
      extra.test = this._name

    this.fail(msg, extra)
  }, this)
}

Test.prototype.endAll = function () {
  var child = this._currentChild

  if (this._queue && this._queue.length)
    this._queueFail()

  if (child) {
    if (!child._ended && child.fail) {
      var msg = 'test unfinished: ' + (child._name || '(unnamed)')
      var extra = { at: child._calledAt }
      if (child._plan !== -1) {
        extra.plan = child._plan
        extra.count = child._count
      }
      child.fail(msg, extra)
    }

    if (child.end)
      child.end()

    if (child.endAll)
      child.endAll()

    if (child.kill)
      child.kill('SIGTERM')

    child._bailedOut = true
  }

  this.end()
}

Test.prototype._extraFromError = function (er, extra) {
  extra = extra || {}
  if (!er || typeof er !== 'object') {
    extra.error = er
    return extra
  }

  var message = er.message
  var addName = true

  if (!message && er.stack) {
    message = er.stack.split('\n')[0]
    addName = false
  }

  er.message = ''
  var st = er.stack
  if (st) {
    st = st.split('\n')
    // parse out the 'at' bit from the first line.
    extra.at = stack.parseLine(st[1])
    extra.stack = stack.clean(st)
  }
  er.message = message

  if (addName && er.name)
    message = er.name + ': ' + message

  Object.keys(er).forEach(function (k) {
    if (k === 'message')
      return
    extra[k] = er[k]
  })

  extra.message = message

  return extra
}

Test.prototype.threw = function threw (er, extra, proxy) {
  this._ok = false
  this._threw = this._threw || er

  if (this._name && !proxy)
    er.test = this._name

  if (!extra)
    extra = this._extraFromError(er)

  // If we've already ended, then try to pass this up the chain
  // Presumably, eventually the root harness will catch it and
  // deal with it, since that only ends on process exit.
  if (this._ended) {
    if (this._parent)
      return this._parent.threw(er, extra, true)
    else
      throw er
  }

  this.fail(extra.message || er.message, extra)
  if (!proxy)
    this.end()
}

Test.prototype.pragma = function (set) {
  if (this._bailedOut)
    return

  if (this._currentChild) {
    this._queue.push(['pragma', set])
    return
  }

  for (var i in set)
    this.push('pragma ' + (set[i] ? '+' : '-') + i + '\n')
}

Test.prototype.plan = function (n, comment) {
  if (this._bailedOut)
    return

  if (this._currentChild) {
    this._queue.push(['plan', n, comment])
    return
  }

  if (this._plan !== -1)
    throw new Error('Cannot set plan more than once')

  if (typeof n !== 'number' || n < 0)
    throw new Error('plan must be a number')

  // Cannot get any tests after a trailing plan, or a plan of 0
  var ending = false
  if (this._count !== 0 || n === 0)
    ending = true

  this._plan = n
  comment = comment ? ' # ' + comment.trim() : ''
  this.push('1..' + n + comment + '\n')

  if (ending)
    this.end()
}

Test.prototype.test = function test (name, extra, cb) {
  if (this._bailedOut)
    return

  if (this._autoendTimer)
    clearTimeout(this._autoendTimer)

  if (typeof name === 'function') {
    cb = name
    name = ''
    extra = {}
  } else if (typeof extra === 'function') {
    cb = extra
    extra = {}
  }

  if (!cb) {
    extra = extra || {}
    extra.todo = true
  } else if (typeof cb !== 'function')
    throw new Error('test() requires a callback')

  if (!name && cb && cb.name)
    name = cb.name

  if (extra.skip || extra.todo)
    return this.pass(name, extra)

  // will want this captured now in case child fails.
  if (!hasOwn(extra, 'at'))
    extra.at = stack.at(test)

  if (this._currentChild) {
    this._queue.push(['test', name, extra, cb])
    return
  }

  var child = new Test(extra)
  name = name || '(unnamed test)'

  child._name = name
  child._parent = this
  if (this._bail)
    child._bail = this._bail

  this._currentChild = child
  var self = this
  childStream(self, child)
  var results
  child.on('complete', function (res) {
    results = pruneFailures(res)
  })
  child.on('end', function () {
    if (child._threw && child._ok) {
      child._ok = false
      extra.error = child._threw
      if (extra.error.stack)
        extra.error.stack = stack.clean(extra.error.stack)
    }
    extra.results = results
    self._currentChild = null
    if (results)
      name += ' # time=' + results.time + 'ms'
    self.ok(child._ok, name, extra)
    if (!self._ended)
      self.push('\n')
  })
  child.on('bailout', function (message) {
    rootBail(self, message)
  })

  // still need try/catch for synchronous errors
  self._level = child
  child.comment('Subtest: ' + name)
  try {
    var cbRet = cb(child)
    if (cbRet && typeof cbRet.then === 'function') {
      // promise
      cbRet.then(function () {
        child.end()
      }, function (reason) {
        child.fail(reason.message, child._extraFromError(reason))
        child.end()
      })
    }
  } catch (er) {
    child.threw(er)
  }
  self._level = self
}

Test.prototype.current = function () {
  var t = this
  while (t._level && t !== t._level)
    t = t._level
  return t
}

// stdin is a bit different than a typical child stream
// It's not treated as a "child test", because we typically
// don't want to indent it or treat as a suite in reporters.
// This is most often used by the runner when - is passed
// as an arg, to run a reporter on a previous run.
// We DO however need to parse it to set the exit failure.
Test.prototype.stdin = function (name, extra) {
  if (typeof name === 'object') {
    extra = name
    name = null
  }

  if (!name)
    name = '/dev/stdin'

  if (!extra)
    extra = {}

  if (!extra.at)
    extra.at = stack.at(stdin)

  if (this._currentChild) {
    this._queue.push(['stdin', name, extra])
    return
  }

  if (extra.skip)
    return this.pass(name, extra)

  var stdin = process.stdin
  this._currentChild = stdin
  var start = process.hrtime()
  var parser = new Parser()
  var self = this

  childStream(self, stdin)

  stdin.on('data', function (c) {
    parser.write(c)
  })

  stdin.emit('data', '# Subtest: ' + name + '\n')

  stdin.on('end', function () {
    parser.end()
  })

  parser.on('complete', function (res) {
    self._currentChild = null
    extra.results = pruneFailures(res)
    var dur = process.hrtime(start)
    var time = Math.round(dur[0] * 1e6 + dur[1] / 1e3) / 1e3
    name += ' # time=' + time + 'ms'
    self.ok(res.ok, name, extra)
    if (!self._ended)
      self.push('\n')
    self._processQueue()
  })

  parser.on('bailout', function (message) {
    rootBail(self, message)
  })

  process.stdin.resume()
}

function pruneFailures (res) {
  if (res.failures) {
    res.failures = res.failures.filter(function (f) {
      return f.tapError
    })
    if (!res.failures.length)
      delete res.failures
  }
  return res
}

function rootBail (self, message) {
  var p = self
  while (p._parent) {
    p._bailedOut = true
    p = p._parent
  }
  p.bailout(message)
}

function childStream (self, child) {
  var bailedOut = false
  var linebuf = ''
  child.on('data', function (c) {
    if (bailedOut)
      return
    linebuf += c
    var lines = linebuf.split('\n')
    linebuf = lines.pop()
    lines.forEach(function (line) {
      if (bailedOut)
        return
      if (line.match(/^\s*Bail out!/))
        bailedOut = true
      if (line.match(/^\s*TAP version \d+$/))
        return
      if (line.trim())
        line = '    ' + line
      self.push(line + '\n')
    })
  })
  child.on('end', function () {
    if (bailedOut)
      return
    if (linebuf)
      self.push('    ' + linebuf + '\n')
  })
}

Test.prototype.spawn = function spawnTest (cmd, args, options, name, extra) {

  if (typeof args === 'string')
    args = [ args ]

  args = args || []

  if (typeof options === 'string') {
    name = options
    options = {}
  }

  options = options || {}
  if (!name) {
    if (cmd === process.execPath) {
      name = args.map(function (a) {
        if (a.indexOf(process.cwd()) === 0)
          return './' + a.substr(process.cwd().length + 1)
        else
          return a
      }).join(' ')
    } else
      name = cmd + ' ' + args.join(' ')
  }

  extra = extra || {}

  assert.equal(typeof cmd, 'string')
  assert(Array.isArray(args))
  assert.equal(options && typeof options, 'object')
  assert.equal(typeof name, 'string')
  assert.equal(extra && typeof extra, 'object')

  // stdout must be a pipe
  if (options.stdio) {
    if (typeof options.stdio === 'string')
      options.stdio = [ options.stdio, 'pipe', options.stdio ]
    else
      options.stdio[1] = 'pipe'
  }

  // will want this captured now in case child fails, before enqueue
  if (!hasOwn(extra, 'at'))
    extra.at = stack.at(spawnTest)

  if (this._autoendTimer)
    clearTimeout(this._autoendTimer)

  if (this._currentChild) {
    this._queue.push(['spawn', cmd, args, options, name, extra])
    return
  }

  if (extra.skip || extra.todo)
    return this.pass(name, extra)

  if (this._bail || options.bail) {
    if (!options.env) {
      options.env = Object.keys(process.env).reduce(function (env, k) {
        env[k] = process.env[k]
        return env
      }, {})
    }
    options.env.TAP_BAIL = '1'
  }

  var start = process.hrtime()
  var child = spawn(cmd, args, options)
  var parser = new Parser()
  var self = this
  this._currentChild = child

  childStream(self, child.stdout)

  child.stdout.on('data', function (c) {
    parser.write(c)
  })

  if (this._bail)
    bailOnFail(this, child.stdout, parser)

  child.stdout.emit('data', '# Subtest: ' + name + '\n')
  // The only thing that's actually *required* to be a valid TAP output
  // is a plan and/or at least one ok/not-ok line.  If we don't get any
  // of those, then emit a bogus 1..0 so we read it as a skip.
  var sawTests = false
  parser.once('assert', function () {
    sawTests = true
  })

  parser.once('plan', function () {
    sawTests = true
  })

  child.stdout.on('end', function () {
    parser.write('\n')
    if (!sawTests)
      child.stdout.emit('data', '1..0\n')
    parser.end()
  })

  var results
  parser.on('complete', function (res) {
    results = pruneFailures(res)
  })

  if (extra.timeout) {
    var timer = setTimeout(function () {
      extra.failure = 'timeout'
      child.kill('SIGTERM')
      // give it 1 more second to finish up
      timer = setTimeout(function () {
        child.stdout.emit('data', '\n\nnot ok - timeout\n\n')
        child.kill('SIGKILL')
      }, 1000)
    }, extra.timeout)
  }

  child.on('close', function onclose (code, signal) {
    clearTimeout(timer)
    self._currentChild = null
    extra.results = results
    var dur = process.hrtime(start)
    var time = Math.round(dur[0] * 1e6 + dur[1] / 1e3) / 1e3
    if (code)
      extra.exitCode = code
    if (signal)
      extra.signal = signal
    extra.command = cmd
    extra.arguments = args

    if (signal || code)
      results.ok = false

    if (results.count === 0 && !signal && !code) {
      extra.skip = 'No tests found'
      if (results.plan && results.plan.skipReason)
        extra.skip = results.plan.skipReason
    } else
      name += ' # time=' + time + 'ms'

    self.ok(results.ok && !code && !signal, name, extra)
    if (!self._ended)
      self.push('\n')
    self._processQueue()
  })

  parser.on('bailout', function (message) {
    child.kill('SIGTERM')
    rootBail(self, message)
  })

  if (child.stderr) {
    child.stderr.on('data', function (c) {
      process.stderr.write(c)
    })
  }
}

function bailOnFail (self, stream, parser) {
  parser.on('child', function (c) {
    bailOnFail(self, stream, c)
  })

  parser.on('assert', function (res) {
    if (!res.todo && !res.skip && !res.ok) {
      var ind = new Array(parser.level * 4 + 1).join(' ')
      parser.buffer = ''
      stream.emit('data', ind + 'Bail out! # ' + res.name + '\n')
    }
  })
}

Test.prototype.done = Test.prototype.end = function end () {
  if (this._bailedOut)
    return

  if (this._ended || this._ending)
    return

  if (this._currentChild) {
    this._queue.push(['end'])
    return
  }

  clearTimeout(this._timer)
  // Emiting the missing tests can trigger a call to end()
  // guard against that with the 'ending' flag
  this._ending = true
  var missing = this._plan - this._count
  while (missing > 0) {
    this.fail('missing test', { at: false })
    missing--
  }

  if (this._plan === -1)
    this.plan(this._count)

  var final = {
    plan: { start: 1, end: this._plan },
    count: this._count,
    pass: this._pass,
    ok: this._ok
  }

  if (this._fail)
    final.fail = this._fail

  if (this._bailedOut)
    final.bailout = true

  if (this._todo)
    final.todo = this._todo

  if (this._skip)
    final.skip = this._skip

  this._ended = true

  // This is nice, but too noisy.
  // TODO: prove-style commenting at the end.
  // this.comment(final)
  if (!this._ok) {
    // comment a bit at the end so we know what happened.
    if (this._plan !== this._count)
      this.comment('actual test count(%d) != plan(%d)',
                   this._count, this._plan)

    if (this._fail > 0)
      this.comment('failed %d of %d tests', this._fail, this._count)
    if (this._todo > 0)
      this.comment('todo: %d', this._todo)
    if (this._skip > 0)
      this.comment('